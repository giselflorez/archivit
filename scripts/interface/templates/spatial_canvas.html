<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IT-R8 Spatial Canvas | ARCHIV-IT</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #ffffff;
            color: #1a1a1a;
            overflow: hidden;
        }

        /* Top Navigation */
        .top-nav {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 50px;
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            display: flex;
            align-items: center;
            padding: 0 20px;
            gap: 20px;
            z-index: 1000;
            border-bottom: 1px solid #3a3a3a;
        }

        .top-nav a {
            color: #888;
            text-decoration: none;
            font-size: 13px;
            transition: color 0.2s;
        }

        .top-nav a:hover, .top-nav a.active {
            color: #fff;
        }

        .top-nav .brand {
            font-weight: 700;
            font-size: 14px;
            color: #fff;
            letter-spacing: 1px;
        }

        .top-nav .brand span {
            color: #f0c674;
        }

        /* Canvas Container */
        #canvas-container {
            position: fixed;
            top: 50px;
            left: 0;
            right: 300px;
            bottom: 0;
            background: #fafafa;
        }

        #three-canvas {
            width: 100%;
            height: 100%;
        }

        /* Right Panel */
        .control-panel {
            position: fixed;
            top: 50px;
            right: 0;
            width: 300px;
            bottom: 0;
            background: #ffffff;
            border-left: 1px solid #e0e0e0;
            overflow-y: auto;
            padding: 20px;
        }

        .panel-section {
            margin-bottom: 25px;
        }

        .panel-section h3 {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            color: #666;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid #eee;
        }

        /* Algorithm Selector */
        .algorithm-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        .algo-btn {
            padding: 12px 8px;
            border: 2px solid #e0e0e0;
            background: #fff;
            border-radius: 8px;
            cursor: pointer;
            text-align: center;
            transition: all 0.2s;
            font-size: 12px;
        }

        .algo-btn:hover {
            border-color: #999;
        }

        .algo-btn.active {
            border-color: #1a1a1a;
            background: #1a1a1a;
            color: #fff;
        }

        .algo-btn .icon {
            font-size: 20px;
            margin-bottom: 4px;
            display: block;
        }

        /* Sliders */
        .slider-group {
            margin-bottom: 16px;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: #666;
            margin-bottom: 6px;
        }

        .slider-value {
            font-family: 'SF Mono', Monaco, monospace;
            color: #1a1a1a;
            font-weight: 600;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            background: #e0e0e0;
            border-radius: 3px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #1a1a1a;
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.1s;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        /* Bubble Stats */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .stat-item {
            background: #f5f5f5;
            padding: 12px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-value {
            font-size: 24px;
            font-weight: 700;
            color: #1a1a1a;
        }

        .stat-label {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #888;
            margin-top: 4px;
        }

        /* Export Buttons */
        .export-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        .export-btn {
            padding: 12px;
            border: none;
            background: #1a1a1a;
            color: #fff;
            border-radius: 8px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        .export-btn:hover {
            background: #333;
            transform: translateY(-1px);
        }

        .export-btn.secondary {
            background: #fff;
            color: #1a1a1a;
            border: 1px solid #e0e0e0;
        }

        .export-btn.secondary:hover {
            background: #f5f5f5;
        }

        /* View Controls */
        .view-controls {
            display: flex;
            gap: 8px;
        }

        .view-btn {
            flex: 1;
            padding: 10px;
            border: 1px solid #e0e0e0;
            background: #fff;
            border-radius: 6px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s;
        }

        .view-btn:hover {
            background: #f5f5f5;
        }

        .view-btn.active {
            background: #1a1a1a;
            color: #fff;
            border-color: #1a1a1a;
        }

        /* Loading Overlay */
        .loading-overlay {
            position: fixed;
            top: 50px;
            left: 0;
            right: 300px;
            bottom: 0;
            background: rgba(255,255,255,0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 500;
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid #e0e0e0;
            border-top-color: #1a1a1a;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            margin-top: 16px;
            font-size: 14px;
            color: #666;
        }

        /* Tooltip */
        .bubble-tooltip {
            position: fixed;
            background: #1a1a1a;
            color: #fff;
            padding: 10px 14px;
            border-radius: 8px;
            font-size: 12px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 1000;
            max-width: 200px;
        }

        .bubble-tooltip.visible {
            opacity: 1;
        }

        .bubble-tooltip .title {
            font-weight: 600;
            margin-bottom: 4px;
        }

        .bubble-tooltip .tags {
            font-size: 10px;
            color: #aaa;
        }

        /* Info Banner */
        .info-banner {
            background: linear-gradient(135deg, #f0c674 0%, #e8b84a 100%);
            color: #1a1a1a;
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 12px;
            margin-bottom: 20px;
        }

        .info-banner strong {
            display: block;
            margin-bottom: 4px;
        }

        /* Color picker for background */
        .color-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .color-picker {
            width: 40px;
            height: 30px;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            cursor: pointer;
            padding: 2px;
        }

        .color-presets {
            display: flex;
            gap: 6px;
        }

        .color-preset {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s;
        }

        .color-preset:hover {
            transform: scale(1.1);
        }

        .color-preset.active {
            border-color: #1a1a1a;
        }
    </style>
</head>
<body>
    <!-- Navigation -->
    <nav class="top-nav">
        <span class="brand"><span>IT-R8</span> SPATIAL CANVAS</span>
        <a href="/">Home</a>
        <a href="/visual-translator">Visual Analyzer</a>
        <a href="/tags">Tags</a>
        <a href="/point-cloud">Point Cloud</a>
        <a href="/semantic-network">Network</a>
        <a href="/spatial-canvas" class="active">Spatial Canvas</a>
    </nav>

    <!-- Three.js Canvas -->
    <div id="canvas-container">
        <canvas id="three-canvas"></canvas>
    </div>

    <!-- Loading Overlay -->
    <div class="loading-overlay" id="loading">
        <div class="loading-spinner"></div>
        <div class="loading-text">Loading bubbles...</div>
    </div>

    <!-- Tooltip -->
    <div class="bubble-tooltip" id="tooltip">
        <div class="title"></div>
        <div class="tags"></div>
    </div>

    <!-- Control Panel -->
    <div class="control-panel">
        <div class="info-banner">
            <strong>IT-R8 Spatial Canvas</strong>
            Make designing fun again. Free forever. No ads.
        </div>

        <!-- Stats -->
        <div class="panel-section">
            <h3>Bubbles Loaded</h3>
            <div class="stats-grid">
                <div class="stat-item">
                    <div class="stat-value" id="bubble-count">0</div>
                    <div class="stat-label">Bubbles</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="image-count">0</div>
                    <div class="stat-label">Images</div>
                </div>
            </div>
        </div>

        <!-- Algorithm Selection -->
        <div class="panel-section">
            <h3>Algorithm</h3>
            <div class="algorithm-grid">
                <button class="algo-btn active" data-algo="spiral">
                    Spiral
                </button>
                <button class="algo-btn" data-algo="helix">
                    Helix
                </button>
                <button class="algo-btn" data-algo="grid">
                    Grid
                </button>
                <button class="algo-btn" data-algo="physics">
                    Gravity
                </button>
                <button class="algo-btn" data-algo="constellation">
                    Constellation
                </button>
                <button class="algo-btn" data-algo="random">
                    Random
                </button>
            </div>
        </div>

        <!-- Algorithm Controls -->
        <div class="panel-section">
            <h3>Controls</h3>

            <div class="slider-group">
                <div class="slider-label">
                    <span>Spread</span>
                    <span class="slider-value" id="spread-value">50</span>
                </div>
                <input type="range" id="spread" min="10" max="100" value="50">
            </div>

            <div class="slider-group">
                <div class="slider-label">
                    <span>Bubble Size</span>
                    <span class="slider-value" id="size-value">1.0</span>
                </div>
                <input type="range" id="bubble-size" min="0.2" max="3" step="0.1" value="1">
            </div>

            <div class="slider-group">
                <div class="slider-label">
                    <span>Rotation Speed</span>
                    <span class="slider-value" id="rotation-value">0.5</span>
                </div>
                <input type="range" id="rotation" min="0" max="2" step="0.1" value="0.5">
            </div>

            <div class="slider-group">
                <div class="slider-label">
                    <span>Depth</span>
                    <span class="slider-value" id="depth-value">30</span>
                </div>
                <input type="range" id="depth" min="0" max="100" value="30">
            </div>
        </div>

        <!-- View Controls -->
        <div class="panel-section">
            <h3>View</h3>
            <div class="view-controls">
                <button class="view-btn active" data-view="3d">3D</button>
                <button class="view-btn" data-view="top">Top</button>
                <button class="view-btn" data-view="front">Front</button>
            </div>
        </div>

        <!-- Background -->
        <div class="panel-section">
            <h3>Background</h3>
            <div class="color-row">
                <div class="color-presets">
                    <div class="color-preset active" style="background: #fafafa" data-color="#fafafa"></div>
                    <div class="color-preset" style="background: #ffffff" data-color="#ffffff"></div>
                    <div class="color-preset" style="background: #1a1a1a" data-color="#1a1a1a"></div>
                    <div class="color-preset" style="background: #0a192f" data-color="#0a192f"></div>
                    <div class="color-preset" style="background: #f0c674" data-color="#f0c674"></div>
                </div>
            </div>
        </div>

        <!-- Export -->
        <div class="panel-section">
            <h3>Export</h3>
            <div class="export-grid">
                <button class="export-btn" id="export-png">
                    PNG
                </button>
                <button class="export-btn" id="export-jpg">
                    JPG
                </button>
                <button class="export-btn secondary" id="reset-view">
                    Reset
                </button>
                <button class="export-btn secondary" id="fullscreen">
                    Fullscreen
                </button>
            </div>
            <div style="margin-top: 12px;">
                <a href="/api/export/itr8" class="export-btn" style="display: block; text-align: center; text-decoration: none; background: linear-gradient(135deg, #f0c674, #e8b84a); color: #1a1a1a;">
                    Export .itr8 for IT-R8
                </a>
            </div>
        </div>

        <!-- Footer Note -->
        <div style="margin-top: auto; padding-top: 20px; border-top: 1px solid #eee; text-align: center;">
            <div style="font-size: 11px; color: #888; line-height: 1.5;">
                <strong style="color: #1a1a1a;">IT-R8</strong> is FREE forever.<br>
                No ads. No subscriptions. 100% local.<br>
                <span style="color: #f0c674;">Make designing fun again.</span>
            </div>
        </div>
    </div>

    <script>
        // ============================================
        // IT-R8 SPATIAL CANVAS - Three.js Implementation
        // ============================================

        let scene, camera, renderer, controls;
        let bubbles = [];
        let bubbleGroup;
        let currentAlgorithm = 'spiral';
        let autoRotate = true;
        let rotationSpeed = 0.5;
        let raycaster, mouse;
        let hoveredBubble = null;

        // Settings
        const settings = {
            spread: 50,
            bubbleSize: 1,
            rotation: 0.5,
            depth: 30,
            backgroundColor: 0xfafafa
        };

        // Initialize Three.js
        function init() {
            const container = document.getElementById('canvas-container');
            const canvas = document.getElementById('three-canvas');

            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(settings.backgroundColor);

            // Camera
            camera = new THREE.PerspectiveCamera(
                60,
                container.clientWidth / container.clientHeight,
                0.1,
                1000
            );
            camera.position.set(0, 0, 100);

            // Renderer
            renderer = new THREE.WebGLRenderer({
                canvas: canvas,
                antialias: true,
                preserveDrawingBuffer: true
            });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 20;
            controls.maxDistance = 300;

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 50, 50);
            scene.add(directionalLight);

            const backLight = new THREE.DirectionalLight(0xffffff, 0.3);
            backLight.position.set(-50, -50, -50);
            scene.add(backLight);

            // Bubble group
            bubbleGroup = new THREE.Group();
            scene.add(bubbleGroup);

            // Raycaster for interaction
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Event listeners
            window.addEventListener('resize', onResize);
            canvas.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('click', onBubbleClick);

            // Load data
            loadBubbleData();

            // Start animation
            animate();
        }

        // Load bubble data from API
        async function loadBubbleData() {
            try {
                const response = await fetch('/api/documents');
                const documents = await response.json();

                let totalImages = 0;

                documents.forEach((doc, index) => {
                    const bubble = createBubble(doc, index);
                    if (bubble) {
                        bubbles.push(bubble);
                        bubbleGroup.add(bubble.mesh);
                        totalImages += doc.media_count || 0;
                    }
                });

                // Update stats
                document.getElementById('bubble-count').textContent = bubbles.length;
                document.getElementById('image-count').textContent = totalImages;

                // Apply initial layout
                applyAlgorithm(currentAlgorithm);

                // Hide loading
                document.getElementById('loading').style.display = 'none';

            } catch (error) {
                console.error('Failed to load bubble data:', error);
                document.querySelector('.loading-text').textContent = 'Failed to load data';
            }
        }

        // Create a bubble from document data
        function createBubble(doc, index) {
            const size = settings.bubbleSize * (0.8 + Math.random() * 0.4);

            // Geometry
            const geometry = new THREE.SphereGeometry(size * 2, 32, 32);

            // Material - try to load image texture
            let material;

            if (doc.first_image) {
                const textureLoader = new THREE.TextureLoader();
                const texture = textureLoader.load(
                    doc.first_image,
                    () => { renderer.render(scene, camera); },
                    undefined,
                    () => {
                        // Fallback color on error
                        material.map = null;
                        material.color.setHex(getColorFromTags(doc.tags));
                        material.needsUpdate = true;
                    }
                );
                texture.minFilter = THREE.LinearFilter;

                material = new THREE.MeshStandardMaterial({
                    map: texture,
                    roughness: 0.3,
                    metalness: 0.1
                });
            } else {
                // Color based on tags or random
                const color = getColorFromTags(doc.tags);
                material = new THREE.MeshStandardMaterial({
                    color: color,
                    roughness: 0.4,
                    metalness: 0.2
                });
            }

            const mesh = new THREE.Mesh(geometry, material);
            mesh.userData = {
                doc: doc,
                index: index,
                baseSize: size
            };

            return {
                mesh: mesh,
                doc: doc,
                targetPosition: new THREE.Vector3()
            };
        }

        // Get color from tags
        function getColorFromTags(tags) {
            if (!tags || tags.length === 0) return 0x888888;

            // Hash the first tag to get a consistent color
            const tag = tags[0].toLowerCase();
            let hash = 0;
            for (let i = 0; i < tag.length; i++) {
                hash = tag.charCodeAt(i) + ((hash << 5) - hash);
            }

            // Generate pastel color
            const h = Math.abs(hash % 360);
            return new THREE.Color(`hsl(${h}, 70%, 60%)`).getHex();
        }

        // ============================================
        // LAYOUT ALGORITHMS
        // ============================================

        function applyAlgorithm(algo) {
            currentAlgorithm = algo;

            switch(algo) {
                case 'spiral':
                    spiralLayout();
                    break;
                case 'helix':
                    helixLayout();
                    break;
                case 'grid':
                    gridLayout();
                    break;
                case 'physics':
                    physicsLayout();
                    break;
                case 'constellation':
                    constellationLayout();
                    break;
                case 'random':
                    randomLayout();
                    break;
            }

            // Animate to new positions
            animateToPositions();
        }

        // Spiral Layout
        function spiralLayout() {
            const spread = settings.spread;
            const depth = settings.depth;

            bubbles.forEach((bubble, i) => {
                const angle = i * 0.5;
                const radius = 5 + (i * spread * 0.05);
                const y = (i - bubbles.length / 2) * (depth * 0.05);

                bubble.targetPosition.set(
                    Math.cos(angle) * radius,
                    y,
                    Math.sin(angle) * radius
                );
            });
        }

        // Helix Layout
        function helixLayout() {
            const spread = settings.spread;
            const depth = settings.depth;

            bubbles.forEach((bubble, i) => {
                const angle = i * 0.3;
                const radius = spread * 0.5;
                const y = (i - bubbles.length / 2) * (depth * 0.08);

                bubble.targetPosition.set(
                    Math.cos(angle) * radius,
                    y,
                    Math.sin(angle) * radius
                );
            });
        }

        // Grid Layout
        function gridLayout() {
            const spread = settings.spread;
            const cols = Math.ceil(Math.sqrt(bubbles.length));
            const spacing = spread * 0.15;

            bubbles.forEach((bubble, i) => {
                const col = i % cols;
                const row = Math.floor(i / cols);
                const layer = Math.floor(i / (cols * cols));

                bubble.targetPosition.set(
                    (col - cols / 2) * spacing,
                    (row - cols / 2) * spacing,
                    layer * spacing * 0.5
                );
            });
        }

        // Physics Layout (random with repulsion simulation)
        function physicsLayout() {
            const spread = settings.spread;

            // Initial random positions
            bubbles.forEach((bubble, i) => {
                bubble.targetPosition.set(
                    (Math.random() - 0.5) * spread * 2,
                    (Math.random() - 0.5) * spread * 2,
                    (Math.random() - 0.5) * spread
                );
            });

            // Simple repulsion simulation
            for (let iter = 0; iter < 50; iter++) {
                bubbles.forEach((bubble, i) => {
                    const force = new THREE.Vector3();

                    bubbles.forEach((other, j) => {
                        if (i === j) return;

                        const diff = bubble.targetPosition.clone().sub(other.targetPosition);
                        const dist = diff.length();

                        if (dist < 10) {
                            diff.normalize().multiplyScalar(10 - dist);
                            force.add(diff);
                        }
                    });

                    bubble.targetPosition.add(force.multiplyScalar(0.1));
                });
            }
        }

        // Constellation Layout
        function constellationLayout() {
            const spread = settings.spread;

            // Group by tags and create clusters
            const tagGroups = {};
            bubbles.forEach(bubble => {
                const tag = bubble.doc.tags?.[0] || 'untagged';
                if (!tagGroups[tag]) tagGroups[tag] = [];
                tagGroups[tag].push(bubble);
            });

            const groupKeys = Object.keys(tagGroups);
            const groupAngle = (Math.PI * 2) / groupKeys.length;

            groupKeys.forEach((tag, groupIndex) => {
                const groupCenter = new THREE.Vector3(
                    Math.cos(groupAngle * groupIndex) * spread,
                    Math.sin(groupAngle * groupIndex) * spread * 0.5,
                    (Math.random() - 0.5) * settings.depth
                );

                tagGroups[tag].forEach((bubble, i) => {
                    const angle = (i / tagGroups[tag].length) * Math.PI * 2;
                    const radius = 5 + Math.random() * 10;

                    bubble.targetPosition.set(
                        groupCenter.x + Math.cos(angle) * radius,
                        groupCenter.y + Math.sin(angle) * radius,
                        groupCenter.z + (Math.random() - 0.5) * 10
                    );
                });
            });
        }

        // Random Layout
        function randomLayout() {
            const spread = settings.spread;
            const depth = settings.depth;

            bubbles.forEach(bubble => {
                bubble.targetPosition.set(
                    (Math.random() - 0.5) * spread * 2,
                    (Math.random() - 0.5) * spread * 2,
                    (Math.random() - 0.5) * depth
                );
            });
        }

        // Animate bubbles to target positions
        function animateToPositions() {
            const duration = 1000;
            const startTime = Date.now();

            bubbles.forEach(bubble => {
                bubble.startPosition = bubble.mesh.position.clone();
            });

            function updatePositions() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const eased = easeOutCubic(progress);

                bubbles.forEach(bubble => {
                    bubble.mesh.position.lerpVectors(
                        bubble.startPosition,
                        bubble.targetPosition,
                        eased
                    );
                });

                if (progress < 1) {
                    requestAnimationFrame(updatePositions);
                }
            }

            updatePositions();
        }

        // Easing function
        function easeOutCubic(t) {
            return 1 - Math.pow(1 - t, 3);
        }

        // ============================================
        // INTERACTION
        // ============================================

        function onMouseMove(event) {
            const container = document.getElementById('canvas-container');
            const rect = container.getBoundingClientRect();

            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            // Raycast
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(bubbleGroup.children);

            const tooltip = document.getElementById('tooltip');

            if (intersects.length > 0) {
                const bubble = intersects[0].object;
                const doc = bubble.userData.doc;

                // Show tooltip
                tooltip.querySelector('.title').textContent = doc.title || 'Untitled';
                tooltip.querySelector('.tags').textContent = doc.tags?.slice(0, 3).join(', ') || '';
                tooltip.style.left = (event.clientX + 15) + 'px';
                tooltip.style.top = (event.clientY + 15) + 'px';
                tooltip.classList.add('visible');

                // Scale up hovered bubble
                if (hoveredBubble !== bubble) {
                    if (hoveredBubble) {
                        hoveredBubble.scale.setScalar(1);
                    }
                    bubble.scale.setScalar(1.2);
                    hoveredBubble = bubble;
                }

                document.body.style.cursor = 'pointer';
            } else {
                tooltip.classList.remove('visible');
                if (hoveredBubble) {
                    hoveredBubble.scale.setScalar(1);
                    hoveredBubble = null;
                }
                document.body.style.cursor = 'default';
            }
        }

        function onBubbleClick(event) {
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(bubbleGroup.children);

            if (intersects.length > 0) {
                const doc = intersects[0].object.userData.doc;
                window.open('/document/' + doc.id, '_blank');
            }
        }

        // ============================================
        // ANIMATION LOOP
        // ============================================

        function animate() {
            requestAnimationFrame(animate);

            // Auto rotation
            if (autoRotate && rotationSpeed > 0) {
                bubbleGroup.rotation.y += 0.001 * rotationSpeed;
            }

            controls.update();
            renderer.render(scene, camera);
        }

        // Resize handler
        function onResize() {
            const container = document.getElementById('canvas-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        // ============================================
        // UI EVENT HANDLERS
        // ============================================

        document.addEventListener('DOMContentLoaded', () => {
            init();

            // Algorithm buttons
            document.querySelectorAll('.algo-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.algo-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    applyAlgorithm(btn.dataset.algo);
                });
            });

            // Sliders
            document.getElementById('spread').addEventListener('input', (e) => {
                settings.spread = parseFloat(e.target.value);
                document.getElementById('spread-value').textContent = settings.spread;
                applyAlgorithm(currentAlgorithm);
            });

            document.getElementById('bubble-size').addEventListener('input', (e) => {
                settings.bubbleSize = parseFloat(e.target.value);
                document.getElementById('size-value').textContent = settings.bubbleSize.toFixed(1);

                bubbles.forEach(bubble => {
                    const scale = settings.bubbleSize * bubble.mesh.userData.baseSize;
                    bubble.mesh.scale.setScalar(scale);
                });
            });

            document.getElementById('rotation').addEventListener('input', (e) => {
                rotationSpeed = parseFloat(e.target.value);
                document.getElementById('rotation-value').textContent = rotationSpeed.toFixed(1);
            });

            document.getElementById('depth').addEventListener('input', (e) => {
                settings.depth = parseFloat(e.target.value);
                document.getElementById('depth-value').textContent = settings.depth;
                applyAlgorithm(currentAlgorithm);
            });

            // View buttons
            document.querySelectorAll('.view-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.view-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');

                    switch(btn.dataset.view) {
                        case '3d':
                            camera.position.set(0, 0, 100);
                            break;
                        case 'top':
                            camera.position.set(0, 100, 0);
                            break;
                        case 'front':
                            camera.position.set(0, 0, 100);
                            camera.position.y = 0;
                            break;
                    }
                    camera.lookAt(0, 0, 0);
                });
            });

            // Background color
            document.querySelectorAll('.color-preset').forEach(preset => {
                preset.addEventListener('click', () => {
                    document.querySelectorAll('.color-preset').forEach(p => p.classList.remove('active'));
                    preset.classList.add('active');

                    const color = preset.dataset.color;
                    scene.background = new THREE.Color(color);
                });
            });

            // Export PNG
            document.getElementById('export-png').addEventListener('click', () => {
                renderer.render(scene, camera);
                const link = document.createElement('a');
                link.download = 'it-r8-canvas-' + Date.now() + '.png';
                link.href = renderer.domElement.toDataURL('image/png');
                link.click();
            });

            // Export JPG
            document.getElementById('export-jpg').addEventListener('click', () => {
                renderer.render(scene, camera);
                const link = document.createElement('a');
                link.download = 'it-r8-canvas-' + Date.now() + '.jpg';
                link.href = renderer.domElement.toDataURL('image/jpeg', 0.9);
                link.click();
            });

            // Reset view
            document.getElementById('reset-view').addEventListener('click', () => {
                camera.position.set(0, 0, 100);
                camera.lookAt(0, 0, 0);
                controls.reset();
                bubbleGroup.rotation.set(0, 0, 0);
            });

            // Fullscreen
            document.getElementById('fullscreen').addEventListener('click', () => {
                const container = document.getElementById('canvas-container');
                if (container.requestFullscreen) {
                    container.requestFullscreen();
                }
            });
        });
    </script>
</body>
</html>
